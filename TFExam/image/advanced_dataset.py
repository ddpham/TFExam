# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/image/01_image_dataset_advanced.ipynb (unless otherwise specified).

__all__ = ['path', 'train_ds', 'valid_ds', 'class_names', 'model', 'flatten', 'prediction', 'base_model',
           'preprocess_ds', 'train_ds', 'valid_ds', 'data_generator', 'bs', 'train_ds', 'valid_ds', 'data_generator',
           'sample', 'repeat_images', 'label', 'figure', 'images', 'get_data_generator', 'get_repeat_images',
           'get_sample_images', 'plot_images', 'aug_tfms', 'repeat_sample', 'sample', 'aug_tfms', 'repeat_sample',
           'sample', 'aug_tfms', 'sample', 'repeat_sample', 'aug_tfms', 'sample', 'repeat_sample', 'aug_tfms', 'sample',
           'repeat_sample', 'aug_tfms', 'sample', 'repeat_sample', 'data_gen', 'bs', 'train_ds1', 'valid_ds1', 'bs',
           'train_ds2', 'valid_ds2', 'create_preprocess_resnet', 'model', 'model', 'preprocess_layer',
           'preprocess_image', 'preprocess_layer', 'bs', 'train_ds2', 'valid_ds2', 'train_ds2', 'valid_ds2',
           'create_resnet50', 'model', 'model', 'bs', 'train_ds', 'valid_ds', 'train_ds', 'valid_ds', 'create_model',
           'model', 'callbacks', 'epochs']

# Cell
import tensorflow as tf
import tensorflow.keras as keras
from tensorflow.keras.preprocessing import image
import matplotlib.pyplot as plt
import numpy as np
from tensorflow.keras.layers.experimental import preprocessing
from tensorflow.keras.layers.experimental.preprocessing import *

# Cell
print("Num GPUs Available: ", len(tf.config.experimental.list_physical_devices('GPU')))

# Cell
path = '/home/ddpham/git/TFExam/data/'

# Cell
train_ds = keras.preprocessing.image_dataset_from_directory(
    directory=f'{path}/sw/train'
    , labels='inferred'
    , label_mode='categorical'
    , batch_size=32
    , image_size=(224, 224)
)
valid_ds = keras.preprocessing.image_dataset_from_directory(
    directory = f'{path}/sw/test'
    , labels='inferred'
    , label_mode='categorical'
    , batch_size=32
    , image_size=(224, 224)
)

# Cell
# Lấy tên thực tế của labels:
class_names = train_ds.class_names
class_names

# Cell
# Kiểm tra dữ liệu của 1 batch:
plt.figure(figsize=(6, 6))
for images, labels in train_ds.take(1):
    # Kiểm tra 9 ảnh:
    for i in range(9):
        ax = plt.subplot(3, 3, i+1)
        plt.imshow(np.uint8(images[i]))
        plt.title(class_names[np.int8(labels[i][1])])
        plt.axis('off')
        plt.tight_layout()

# Cell
from keras.applications import resnet50

# Cell
# Tạo một base model, trong đó, lọc bỏ 2 layers cuối cùng (flatten và predict) của model đã được đào tạo rồi:
model = resnet50.ResNet50(include_top=False, weights='imagenet', input_shape=[224, 224, 3])
model.summary()

# Cell
for layer in model.layers:
    layer.trainable=False

# Cell
flatten = keras.layers.Flatten()(model.output) # Kéo phẳng kết quả của model ResNet50
prediction = keras.layers.Dense(2, activation='sigmoid', name='prediction')(flatten)
base_model = keras.models.Model(inputs=model.inputs, outputs=prediction)
base_model.summary()

# Cell
# Tổng kết model:
base_model.compile(optimizer='rmsprop', loss='binary_crossentropy', metrics=['accuracy'])

# Cell
# Tạo hàm biến đổi dữ liệu ảnh theo dạng dữ liệu đầu vào của resnet50:
# The images are converted from RGB to BGR, then each color channel is
# zero-centered with respect to the ImageNet dataset, without scaling.
def preprocess_ds(image, label):
    image = resnet50.preprocess_input(image)
    return (image, label)

# Cell
# hàm map trong dataset của keras có thể hỗ trợ chúng ta map các phương pháp biến đổi dữ liệu vào trong dữ liệu dạng dataset:
train_ds = train_ds.map(preprocess_ds)
valid_ds = valid_ds.map(preprocess_ds)

# Cell
base_model.fit(train_ds, epochs=10, validation_data=valid_ds)

# Cell
# Tạo một ImageDataGenerator:
data_generator = image.ImageDataGenerator(
    featurewise_center=True
    , featurewise_std_normalization=True
    , fill_mode='reflection'
    , rescale=1./255
    , preprocessing_function=preprocess_ds_adj
)

# Cell
# Tạo tập dữ liệu, sử dụng phương pháp: `flow_from_directory:`
bs = 16
train_ds = data_generator.flow_from_directory(
    directory=f'{path}/sw/train'
    , target_size=(224, 224)
    , class_mode='categorical'
    , batch_size=bs
)
valid_ds = data_generator.flow_from_directory(
    directory=f'{path}/sw/test'
    , target_size=(224, 224)
    , class_mode='categorical'
    , batch_size=bs
)

# Cell
base_model.fit(train_ds, epochs=10, validation_data=valid_ds)

# Cell
data_generator = image.ImageDataGenerator(
    rotation_range=120
    , rescale=1./255
    , fill_mode='nearest' # phản chiếu lại ảnh nếu ảnh bị trống khi xoay ảnh
)
sample = data_generator.flow_from_directory(
    directory=f'{path}/sw/train'
    , batch_size=9
    , shuffle=True
    , target_size=(224, 224)
)

# Cell
repeat_images = [sample[1][0][0] for i in range(10)]
label = list(sample.class_indices.keys())[np.int8(sample[0][1][0][1])]

# Cell
figure = plt.figure(figsize=(6, 6))
for i in range(9):
    plt.subplot(3, 3, i+1)
    plt.imshow(repeat_images[i])
    plt.title(label)
    plt.axis('off')
    plt.tight_layout()

# Cell
## Xem các ảnh khác:
images = sample.next()
plt.figure(figsize=(6, 6))
for i in range(9):
    plt.subplot(3, 3, i+1)
    plt.imshow(images[0][i])
    plt.axis('off')
    plt.tight_layout()

# Cell
# Tạo hàm sinh ra data generator từ các đk biến đổi dữ liệu aug_tfms và load dữ liệu từ folder:
def get_data_generator(aug_tfms: dict, bs:int=32, size:int=224, seed=42):
    return image.ImageDataGenerator(**aug_tfms).flow_from_directory(
        directory=f'{path}/sw/train'
        , batch_size=bs
        , target_size=(size, size)
        , shuffle=True
        , seed=seed
    )

# Tạo hàm sinh ra dữ liệu lặp lại sample để vẻ từ data generator:
def get_repeat_images(aug_tfms:dict, seed:int) -> tuple:
    # batch_size:
    bs = 9
    sample = get_data_generator(aug_tfms, bs=bs, seed=seed)
    class_names = list(sample.class_indices.keys())
    repeat_images = [sample[0][0][0] for i in range(bs)]
    label = class_names[np.int8(sample[0][1][0][1])]
    label = [label for i in range(bs)]
    return (repeat_images, label)

# # Tạo hàm sinh dữ liệu ngẫu nhiên sample từ data generator:
def get_sample_images(aug_tfms, seed):
    # batch_size:
    bs = 9
    sample = get_data_generator(aug_tfms, bs=bs, seed=seed)
    sample_images = sample.next()
    class_names = list(sample.class_indices.keys())
    images = sample_images[0]
    label = [class_names[np.int8(sample_images[1][i][1])] for i in range(bs)]
    return (images, label)


# Tạo hàm vẽ dữ liệu sample:
def plot_images(images):
    plt.figure(figsize=(6, 6))
    for i in range(9):
        plt.subplot(3, 3, i+1)
        plt.imshow(images[0][i])
        plt.title(images[1][i])
        plt.axis('off')
        plt.tight_layout()

# Cell
aug_tfms = dict(rescale=1./255
    , fill_mode='nearest'
    , horizontal_flip=True
#     , vertical_flip=True
)

# Cell
repeat_sample = get_repeat_images(aug_tfms, seed=1)
sample = get_sample_images(aug_tfms, seed=1)

# Cell
plot_images(sample)

# Cell
plot_images(repeat_sample)

# Cell
# Sử dụng brightness_range:
aug_tfms = dict(rescale=1./255
    , fill_mode='nearest'
    , brightness_range=(.2, .95)
)
repeat_sample = get_repeat_images(aug_tfms, seed=1)
sample = get_sample_images(aug_tfms, seed=1)

# Cell
plot_images(repeat_sample)

# Cell
plot_images(sample)

# Cell
aug_tfms = dict(
    rescale=1./255
    , zca_whitening=True
    , zca_epsilon=5e-6
)
sample = get_sample_images(aug_tfms, seed=1)
repeat_sample = get_repeat_images(aug_tfms, seed=1)

# Cell
plot_images(repeat_sample)

# Cell
plot_images(sample)

# Cell
aug_tfms = dict(
    rescale=1./255
    , width_shift_range=.3
    , height_shift_range=-.3
)
sample = get_sample_images(aug_tfms, seed=1)
repeat_sample = get_repeat_images(aug_tfms, seed=1)

# Cell
plot_images(repeat_sample)

# Cell
plot_images(sample)

# Cell
aug_tfms = dict(rescale=1./255, zoom_range=[1-.5, 1+.5])
sample = get_sample_images(aug_tfms, seed=1)
repeat_sample = get_repeat_images(aug_tfms, seed=1)

# Cell
plot_images(repeat_sample)

# Cell
aug_tfms = dict(rescale=1./255, shear_range=30)
sample = get_sample_images(aug_tfms, seed=1)
repeat_sample = get_repeat_images(aug_tfms, seed=1)

# Cell
plot_images(sample)

# Cell
plot_images(repeat_sample)

# Cell
# Tạo một ImageDataGenerator:
data_gen = keras.preprocessing.image.ImageDataGenerator() ## tạo tập generator trống (ko có phương pháp biến đổi dữ liệu)

# Tạo train & valid generator:
bs = 16
train_ds1 = data_gen.flow_from_directory(
    directory=f'{path}/sw/train'
    , target_size=(460, 460) # Mở size cho các ảnh để dễ trong việc biến đổi dữ liệu ở các bước sau
    , class_mode='binary'
    , batch_size=bs
    , shuffle=True
)
valid_ds1 = data_gen.flow_from_directory(
    directory=f'{path}/sw/test'
    , target_size=(460, 460)
    , class_mode='binary'
    , batch_size=bs
    , shuffle=True
)

# Cell
# Chúng ta sẽ sử dụng image_dataset_from_directory:
bs = 16
train_ds2 = keras.preprocessing.image_dataset_from_directory(
    directory=f'{path}/sw/train'
    , labels='inferred'
    , label_mode='binary'
    , image_size=(460, 460)
    , batch_size=bs
    , shuffle=True
)
valid_ds2 = keras.preprocessing.image_dataset_from_directory(
    directory=f'{path}/sw/test'
    , labels='inferred'
    , label_mode='binary'
    , image_size=(460, 460)
    , batch_size=bs
    , shuffle=True
)

# # Prefetch dữ liệu trên CPU để sẵn sàng cho cách lần train:
# train_ds2 = train_ds2.prefetch(buffer_size=16)
# valid_ds2 = valid_ds2.prefetch(buffer_size=16)

# Cell
# Tạo model resnet50:
def create_preprocess_resnet(input_size:int, class_num:int=2):
    activation = 'sigmoid'
    if class_num > 2: activation = 'softmax'

    # Tạo input:
    input = keras.Input(shape=(input_size, input_size, 3))

    # Tạo layer biến đổi dữ liệu:
    x = keras.Sequential([
        preprocessing.Resizing(224, 224, interpolation='nearest') # cho về size của model
#         , preprocessing.Rescaling(scale=1./255)
#         , preprocessing.Normalization(mean=[0.485, 0.456, 0.406], variance=[0.229**2, 0.224**2, 0.225**2]) # thông số của imagenet
        , keras.layers.Lambda(lambda x: keras.applications.resnet50.preprocess_input(x)) # preprocess_input của resnet50
    ])(input)

    # Tạo preprained resnet:
    resnet_model = keras.applications.resnet50.ResNet50(include_top=False, weights='imagenet', input_shape=(224, 224, 3))

    # Đóng băng các layers của resnet_model:
    for layer in resnet_model.layers:
        layer.trainable = False

    # Trồng resnet_model lên trên input layer:
    resnet_model = resnet_model(x)

    # Bổ sung 2 layers cuối:
    flatten = keras.layers.Flatten(name='flatten')(resnet_model)
    prediction = keras.layers.Dense(class_num, activation=activation, name='prediction')(flatten)
    model = keras.Model(inputs=input, outputs=prediction)
    return model

# Cell
keras.backend.clear_session()
model = create_preprocess_resnet(460, 2)
model.compile(optimizer='rmsprop', loss='sparse_categorical_crossentropy', metrics=['accuracy'])
model.summary()
%time
model.fit(train_ds1, epochs=5, validation_data=valid_ds1)

# Cell
keras.backend.clear_session()
model = create_preprocess_resnet(460, 2)
model.compile(optimizer='rmsprop', loss='sparse_categorical_crossentropy', metrics=['accuracy'])
model.summary()
%time
model.fit(train_ds2, epochs=5, validation_data=valid_ds2)

# Cell
# Tạo ra preprocessing layer:
preprocess_layer = keras.Sequential([
    preprocessing.Resizing(224, 224, interpolation='nearest') # cho về size của model
    , preprocessing.RandomFlip('vertical')
    , preprocessing.Rescaling(scale=1./255)
    , preprocessing.Normalization(mean=[0.485, 0.456, 0.406], variance=[0.229**2, 0.224**2, 0.225**2]) # thông số của imagenet

])

# Cell
# Tạo hàm preprocess dữ liệu:
preprocess_layer = keras.Sequential([
    preprocessing.RandomCrop(224, 224) # crop về kích cỡ của resnet50
    , preprocessing.RandomFlip(mode='vertical')
    , preprocessing.RandomContrast(.8)
])

def preprocess_image(image, label):
    image = preprocess_layer(image, training=True)
    image = keras.applications.resnet50.preprocess_input(image)
    return image, label

# Cell
# Chúng ta sẽ sử dụng image_dataset_from_directory:
bs = 16
train_ds2 = keras.preprocessing.image_dataset_from_directory(
    directory=f'{path}/sw/train'
    , labels='inferred'
    , label_mode='binary'
    , batch_size=bs
    , image_size=(460, 460)
    , shuffle=True
)
valid_ds2 = keras.preprocessing.image_dataset_from_directory(
    directory=f'{path}/sw/train'
    , labels='inferred'
    , label_mode='binary'
    , batch_size=bs
    , image_size=(460, 460)
    , shuffle=True
)

train_ds2 = train_ds2.map(preprocess_image)
valid_ds2 = valid_ds2.map(preprocess_image)

# Cell
def create_resnet50(input_shape:int, class_num:str):
    # Tạo activation:
    activation = 'sigmoid'
    if class_num > 2: activation = 'softmax'

    # Tạo pretrained model:
    resnet_model = keras.applications.resnet50.ResNet50(
        include_top=False
        , weights='imagenet'
        , input_shape=(input_shape, input_shape, 3)
    )

    # Đóng băng các layers của resnet_model:
    for layer in resnet_model.layers:
        layer.trainable = False

    # Bổ sung 2 layers cuối:
    flatten = keras.layers.Flatten(name='flatten')(resnet_model.output)
    prediction = keras.layers.Dense(class_num, activation=activation, name='prediction')(flatten)
    model = keras.Model(inputs=resnet_model.inputs, outputs=prediction)
    return model

# Cell
## với loss = 'binary_classification'
keras.backend.clear_session()
model = create_resnet50(224, 1)
model.compile(optimizer='adam', loss='binary_crossentropy', metrics='accuracy')
model.summary()
model.fit(train_ds2, epochs=5, validation_data=valid_ds2)

# Cell
## với loss = 'sparse_categorical_crossentropy'
keras.backend.clear_session()
model = create_resnet50(224, 2)
model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics='accuracy')
model.summary()
model.fit(train_ds2, epochs=5, validation_data=valid_ds2)

# Cell
# Chúng ta sẽ sử dụng image_dataset_from_directory:
bs = 16
train_ds = keras.preprocessing.image_dataset_from_directory(
    directory=f'{path}/sw/train'
    , labels='inferred'
    , label_mode='binary'
    , batch_size=bs
    , image_size=(460, 460)
    , shuffle=True
)
valid_ds = keras.preprocessing.image_dataset_from_directory(
    directory=f'{path}/sw/train'
    , labels='inferred'
    , label_mode='binary'
    , batch_size=bs
    , image_size=(460, 460)
    , shuffle=True
)

train_ds = train_ds.map(preprocess_image)
valid_ds = valid_ds.map(preprocess_image)

# Cell
# Xây dựng model:
def create_model(input_shape:tuple, num_class:int):
    activation='sigmoid'
    units = 1
    if num_class > 2:
        activation='softmax'
        units = num_class

    inputs = keras.layers.Input(shape=input_shape)
    x = preprocess_layer(inputs)

    # entry block:
    x = keras.layers.Conv2D(32, 3, strides=2, padding='same')(x)
    x = keras.layers.BatchNormalization()(x)
    x = keras.layers.Activation('relu')(x)

    x = keras.layers.Conv2D(64, 3, padding='same')(x)
    x = keras.layers.BatchNormalization()(x)
    x = keras.layers.Activation('relu')(x)

    previous_block_activation = x # set a side residual block

    for size  in [128, 256, 512, 728]:
        x = keras.layers.Activation('relu')(x)
        x = keras.layers.SeparableConv2D(size, 3, padding='same')(x)
        x = keras.layers.BatchNormalization()(x)

        x = keras.layers.Activation('relu')(x)
        x = keras.layers.SeparableConv2D(size, 3, padding='same')(x)
        x = keras.layers.BatchNormalization()(x)

        x = keras.layers.MaxPooling2D(3, strides=2, padding='same')(x)

        # project residual:
        residual = keras.layers.Conv2D(size, 1, strides=2, padding='same')(previous_block_activation)
        x = keras.layers.add([x, residual]) # add back residual block
        previous_block_activation = x # set aside next residual block

    x = keras.layers.SeparableConv2D(1024, 3, padding='same')(x)
    x = keras.layers.BatchNormalization()(x)
    x = keras.layers.Activation('relu')(x)

    x = keras.layers.GlobalAveragePooling2D()(x)
    x = keras.layers.Dropout(0.5)(x)
    outputs = keras.layers.Dense(units, activation=activation)(x)
    return keras.Model(inputs, outputs)

# Cell
keras.backend.clear_session()
model = create_model((224, 224, 3), 2)
model.summary()

# Cell
# Vẽ model:
from tensorflow.keras.utils import plot_model
plot_model(model, show_shapes=True)

# Cell
# Train model:
callbacks = [keras.callbacks.ModelCheckpoint(f'save_at_{epochs}.h5')]
model.compile(
    optimizer=keras.optimizers.Adam(1e-3)
    , loss = 'binary_crossentropy'
    , metrics=['accuracy']
)

# Cell
epochs = 5
model.fit(train_ds, epochs=epochs, callbacks=callbacks, validation_data=valid_ds)